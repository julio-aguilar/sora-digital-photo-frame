<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Photo Frame - Slideshow</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/basecoat-css@0.3.1/dist/basecoat.cdn.min.css">
    <script src="https://cdn.jsdelivr.net/npm/basecoat-css@0.3.1/dist/js/all.min.js" defer></script>
    <!-- Theme Switcher Script -->
    <script>
        (() => {
            try {
                const stored = localStorage.getItem('themeMode');
                if (stored ? stored === 'dark' : matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.add('dark');
                }
            } catch (_) { }

            document.addEventListener('basecoat:theme', (e) => {
                const mode = e.detail?.mode || (document.documentElement.classList.contains('dark') ? 'light' : 'dark');
                if (mode === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('themeMode', mode);
            });
        })();
    </script>

    <style>
        body {
            background: var(--background);
            color: var(--foreground);
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Full screen slideshow layout */
        .slideshow-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: black;
        }

        .slide {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        .slide.active {
            opacity: 1;
        }

        .slide img {
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            width: 0%;
            transition: width 0.1s linear;
            z-index: 10;
        }

        .controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .slideshow-container:hover .controls {
            opacity: 1;
        }

        .fullscreen .controls {
            opacity: 0;
        }

        .fullscreen:hover .controls {
            opacity: 1;
        }

        .info-overlay {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            z-index: 15;
            transition: opacity 0.3s ease;
        }

        .info-overlay.hidden {
            opacity: 0;
        }

        /* Cursor auto-hide */
        body.hide-cursor {
            cursor: none;
        }

        /* Auth overlay */
        .auth-overlay {
            background: var(--background);
            position: fixed;
            inset: 0;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .auth-overlay.hidden {
            display: none;
        }

        /* Weather and Clock Widget */
        .weather-widget {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 15;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 1rem;
            padding: 0.5rem 0.75rem;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-family: 'Nunito', sans-serif;
            transition: opacity 0.3s ease;
            width: auto;
        }

        .weather-widget.loading {
            opacity: 0.5;
        }

        .time-display {
            font-size: 2rem;
            font-weight: 600;
            line-height: 1;
        }
        
        .date-display {
            font-size: 0.85rem;
            font-weight: 400;
            opacity: 0.8;
            margin-top: 0.15rem;
            line-height: 1;
        }
        
        .time-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .weather-display {
            display: flex;
            align-items: center;
            gap: 0.15rem;
            font-size: 1.5rem;
            font-weight: 500;
        }

        .weather-icon {
            font-size: 1.75rem;
            line-height: 1;
            display: inline-block;
        }
    </style>
</head>

<body>
    <!-- Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="card max-w-md w-full mx-4  justify-center">
            <header class="gap-2 flex flex-col items-center justify-center">
                <div class="btn-lg-icon-outline">ðŸ”’</div>
                <h2>Welcome</h2>
                <p class="text-muted-foreground">Enter your PIN to access the photo slideshow</p>
            </header>

            <section>
                <form class="form grid gap-6" id="pinForm" novalidate>
                    <div class="grid gap-2">
                        <label for="pinInput" class="label">PIN</label>
                        <input type="password" id="pinInput" class="input text-center text-2xl tracking-widest"
                            placeholder="â€¢â€¢â€¢â€¢" maxlength="6" autocomplete="off" inputmode="numeric">
                        <p class="text-muted-foreground text-sm">Enter your 4-6 digit PIN</p>
                    </div>
                    <button type="submit" form="pinForm" class="btn w-full" id="authButton">
                        <span class="material-icons">lock_open</span>
                        Access Slideshow
                    </button>
                </form>
            </section>

            <footer>
                <!-- Error Alert -->
                <div class="alert-destructive hidden mb-4" id="authErrorAlert">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" />
                        <line x1="15" y1="9" x2="9" y2="15" />
                        <line x1="9" y1="9" x2="15" y2="15" />
                    </svg>
                    <h2>Authentication Failed</h2>
                    <section id="authErrorMessage">Invalid PIN entered</section>
                </div>

                <!-- Loading State -->
                <div class="flex items-center justify-center gap-2 text-muted-foreground text-sm hidden mb-4"
                    id="authLoading">
                    <div class="bg-accent animate-pulse size-4 shrink-0 rounded-full"></div>
                    <span>Authenticating...</span>
                </div>


            </footer>
        </div>
    </div>

    <!-- Slideshow Container -->
    <div class="slideshow-container" id="slideshowContainer">
        <!-- Loading State -->
        <div class="absolute inset-0 flex flex-col items-center justify-center text-white" id="loadingState">
            <div class="flex items-center gap-4 mb-4">
                <div class="bg-white/20 animate-pulse size-12 shrink-0 rounded-full"></div>
                <div class="grid gap-2">
                    <div class="bg-white/20 animate-pulse rounded-md h-4 w-[200px]"></div>
                    <div class="bg-white/20 animate-pulse rounded-md h-4 w-[150px]"></div>
                </div>
            </div>
            <p class="text-xl text-center">Loading your photos...</p>
        </div>

        <!-- Error State -->
        <div class="absolute inset-0 flex items-center justify-center hidden" id="errorState">
            <div class="alert-destructive max-w-md">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" />
                    <line x1="15" y1="9" x2="9" y2="15" />
                    <line x1="9" y1="9" x2="15" y2="15" />
                </svg>
                <h2>Connection Error</h2>
                <section id="errorMessage">Unable to load images. Please check your connection.</section>
            </div>
        </div>

        <!-- Photo Slides -->
        <div class="slide" id="slide1">
            <img id="image1" alt="Photo">
        </div>

        <div class="slide" id="slide2">
            <img id="image2" alt="Photo">
        </div>

        <!-- Progress Bar -->
        <div class="progress-bar" id="progressBar"></div>

        <!-- Controls -->
        <div class="controls flex gap-2" id="controls">
            <div id="folderSelector" class="mr-2">
                <!-- Folder selector will be initialized here -->
            </div>

            <button class="btn-icon bg-white/20 hover:bg-white/30 backdrop-blur text-white" id="fullscreenBtn"
                data-tooltip="Toggle Fullscreen" data-side="bottom">
                <span class="material-icons">fullscreen</span>
            </button>

            <button class="btn-icon bg-white/20 hover:bg-white/30 backdrop-blur text-white" id="infoBtn"
                data-tooltip="Show Info" data-side="bottom">
                <span class="material-icons">info</span>
            </button>

            <button class="btn-icon bg-white/20 hover:bg-white/30 backdrop-blur text-white" id="logoutBtn"
                data-tooltip="Logout" data-side="bottom">
                <span class="material-icons">logout</span>
            </button>
        </div>

        <!-- Weather and Clock Widget -->
        <div class="weather-widget" id="weatherWidget">
            <div class="time-section">
                <div class="time-display" id="timeDisplay">--:--</div>
                <div class="date-display" id="dateDisplay">---</div>
            </div>
            <div class="weather-display">
                <span class="weather-icon" id="weatherIcon">â˜€</span>
                <span id="tempDisplay">--Â°</span>
            </div>
        </div>

        <!-- Info Overlay -->
        <div class="info-overlay hidden" id="infoOverlay">
            <div class="card bg-background/90 backdrop-blur-md">
                <section class="grid gap-1">
                    <div id="filename" class="font-medium text-foreground"></div>
                    <div id="folder" class="text-sm text-muted-foreground"></div>
                </section>
            </div>
        </div>
    </div>

    <!-- Load folder selection scripts -->
    <script src="/js/folderService.js"></script>
    <script src="/js/folderStorage.js"></script>
    <script src="/js/folderSelector.js"></script>

    <script>
        class AuthenticationManager {
            constructor() {
                this.isAuthenticated = false;
                this.authOverlay = document.getElementById('authOverlay');
                this.pinForm = document.getElementById('pinForm');
                this.pinInput = document.getElementById('pinInput');
                this.authButton = document.getElementById('authButton');
                this.authErrorAlert = document.getElementById('authErrorAlert');
                this.authErrorMessage = document.getElementById('authErrorMessage');
                this.authLoading = document.getElementById('authLoading');

                this.init();
            }

            init() {
                this.bindEvents();
                this.checkExistingSession();
            }

            bindEvents() {
                this.pinForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.authenticate();
                });

                this.pinInput.addEventListener('input', () => {
                    this.clearError();
                    this.clearErrorState();
                });

                this.pinInput.addEventListener('keypress', (e) => {
                    // Allow Enter key to submit form
                    if (e.key === 'Enter') {
                        return;
                    }
                    // Only allow numeric input
                    if (!/[0-9]/.test(e.key) && e.key !== 'Backspace' && e.key !== 'Delete' && e.key !== 'Tab') {
                        e.preventDefault();
                    }
                });
            }

            async checkExistingSession() {
                try {
                    const response = await fetch('/api/auth/session');
                    const data = await response.json();

                    if (data.authenticated) {
                        this.handleAuthSuccess(data.account);
                    } else {
                        this.showAuthOverlay();
                    }
                } catch (error) {
                    console.error('Session check failed:', error);
                    this.showAuthOverlay();
                }
            }

            async authenticate() {
                const pin = this.pinInput.value.trim();

                if (!pin) {
                    this.showError('Please enter your PIN');
                    return;
                }

                if (pin.length < 4) {
                    this.showError('PIN must be at least 4 digits');
                    return;
                }

                this.setLoading(true);

                try {
                    const response = await fetch('/api/auth/pin', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pin })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.handleAuthSuccess(data.account);
                    } else {
                        this.handleAuthError(data.error, data.code);
                    }
                } catch (error) {
                    console.error('Authentication error:', error);
                    this.showError('Connection error. Please try again.');
                } finally {
                    this.setLoading(false);
                }
            }

            handleAuthSuccess(account) {
                this.isAuthenticated = true;
                this.userAccount = account;

                sessionStorage.setItem('authenticated', 'true');
                sessionStorage.setItem('accountName', account.name);

                this.hideAuthOverlay();

                document.dispatchEvent(new CustomEvent('authenticationComplete', {
                    detail: { account }
                }));
            }

            handleAuthError(error, errorCode) {
                this.showError(error || 'Invalid PIN');

                if (errorCode === 'RATE_LIMITED') {
                    this.pinInput.disabled = true;
                    this.pinInput.classList.add('border-destructive');
                    this.authButton.disabled = true;
                } else {
                    this.pinInput.classList.add('border-destructive');
                    this.pinInput.focus();
                }
            }

            async logout() {
                try {
                    await fetch('/api/auth/session', { method: 'DELETE' });
                } catch (error) {
                    console.error('Logout error:', error);
                } finally {
                    this.isAuthenticated = false;
                    this.userAccount = null;
                    sessionStorage.removeItem('authenticated');
                    sessionStorage.removeItem('accountName');
                    this.showAuthOverlay();
                    this.clearForm();

                    if (window.slideshow) {
                        window.slideshow.cleanup();
                    }
                }
            }

            showAuthOverlay() {
                this.authOverlay.classList.remove('hidden');
                setTimeout(() => this.pinInput.focus(), 100);
            }

            hideAuthOverlay() {
                this.authOverlay.classList.add('hidden');
            }

            setLoading(loading) {
                this.authButton.disabled = loading;
                this.pinInput.disabled = loading;

                if (loading) {
                    this.authLoading.classList.remove('hidden');
                    this.clearError();
                } else {
                    this.authLoading.classList.add('hidden');
                }
            }

            showError(message) {
                this.authErrorMessage.textContent = message;
                this.authErrorAlert.classList.remove('hidden');
            }

            clearError() {
                this.authErrorAlert.classList.add('hidden');
                this.authErrorMessage.textContent = '';
            }

            clearErrorState() {
                this.pinInput.classList.remove('border-destructive');
                this.pinInput.disabled = false;
                this.authButton.disabled = false;
            }

            clearForm() {
                this.pinInput.value = '';
                this.clearError();
                this.clearErrorState();
                this.pinInput.disabled = false;
                this.authButton.disabled = false;
            }
        }

        class PhotoFrameSlideshow {
            constructor() {
                this.currentSlide = 0;
                this.isPlaying = true;
                this.interval = 15000; // 15 seconds
                this.timer = null;
                this.progressTimer = null;
                this.cursorHideTimer = null;
                this.controlsHideTimer = null;
                this.wakeLock = null;
                this.folderSelector = null;
                this.folderStorage = new FolderStorage();

                this.initializeElements();
                this.setupEventListeners();
                this.setupCursorAutoHide();
                this.requestWakeLock();
            }

            initializeElements() {
                this.slides = [
                    document.getElementById('slide1'),
                    document.getElementById('slide2')
                ];
                this.images = [
                    document.getElementById('image1'),
                    document.getElementById('image2')
                ];
                this.loadingState = document.getElementById('loadingState');
                this.errorState = document.getElementById('errorState');
                this.errorMessage = document.getElementById('errorMessage');
                this.progressBar = document.getElementById('progressBar');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.infoBtn = document.getElementById('infoBtn');
                this.logoutBtn = document.getElementById('logoutBtn');
                this.infoOverlay = document.getElementById('infoOverlay');
                this.filename = document.getElementById('filename');
                this.folder = document.getElementById('folder');

                this.errorState.classList.add('hidden');
                this.images.forEach(img => img.removeAttribute('src'));
            }

            setupEventListeners() {
                this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                this.infoBtn.addEventListener('click', () => this.toggleInfo());
                this.logoutBtn.addEventListener('click', () => this.logout());

                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case ' ': // Space
                        case 'k':
                        case 'K':
                            e.preventDefault();
                            this.togglePlayPause();
                            break;
                        case 'ArrowRight':
                        case 'n':
                        case 'N':
                            e.preventDefault();
                            this.nextImage();
                            break;
                        case 'f':
                        case 'F':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 'i':
                        case 'I':
                            e.preventDefault();
                            this.toggleInfo();
                            break;
                        case 'Escape':
                            if (document.fullscreenElement) {
                                document.exitFullscreen();
                            }
                            break;
                    }
                });

                // Mouse and touch events to show controls
                document.addEventListener('mousemove', () => {
                    this.showControlsTemporarily();
                });
                
                document.addEventListener('touchstart', () => {
                    this.showControlsTemporarily();
                });
                
                document.addEventListener('click', () => {
                    this.showControlsTemporarily();
                });

                // Handle fullscreen change events
                document.addEventListener('fullscreenchange', () => {
                    if (!document.fullscreenElement) {
                        document.body.classList.remove('fullscreen');
                    }
                });
                
                document.addEventListener('webkitfullscreenchange', () => {
                    if (!document.webkitFullscreenElement) {
                        document.body.classList.remove('fullscreen');
                    }
                });

                this.images.forEach(img => {
                    img.addEventListener('error', () => {
                        if (this.errorState.classList.contains('hidden')) {
                            this.showError('Failed to load image');
                        }
                    });
                });
            }

            async fetchRandomImage() {
                try {
                    const selectedFolderPath = this.folderStorage.getCurrentFolderPath();
                    const url = selectedFolderPath
                        ? `/api/images/random?folder=${encodeURIComponent(selectedFolderPath)}`
                        : '/api/images/random';

                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Failed to fetch image');
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to fetch image');
                    }

                    return data.image;
                } catch (error) {
                    console.error('Error fetching random image:', error);
                    this.showError(`Failed to load image: ${error.message}`);
                    return null;
                }
            }

            async loadImage(imageData) {
                if (!imageData) return false;

                return new Promise((resolve) => {
                    const nextSlide = (this.currentSlide + 1) % 2;
                    const img = this.images[nextSlide];

                    const onLoad = () => {
                        img.removeEventListener('load', onLoad);
                        img.removeEventListener('error', onError);
                        this.hideError();
                        this.currentImageData = imageData;
                        resolve(true);
                    };

                    const onError = (event) => {
                        img.removeEventListener('load', onLoad);
                        img.removeEventListener('error', onError);
                        console.error('Failed to load image:', imageData.url);
                        if (this.errorState.classList.contains('hidden')) {
                            this.showError(`Failed to load image: ${imageData.filename}`);
                        }
                        resolve(false);
                    };

                    img.addEventListener('load', onLoad);
                    img.addEventListener('error', onError);
                    img.src = imageData.url;
                });
            }

            showImage() {
                const currentSlideEl = this.slides[this.currentSlide];
                const nextSlideEl = this.slides[(this.currentSlide + 1) % 2];

                currentSlideEl.classList.remove('active');
                nextSlideEl.classList.add('active');

                this.currentSlide = (this.currentSlide + 1) % 2;
                this.updateInfo();
                this.loadingState.classList.add('hidden');
                this.hideError();
            }

            updateInfo() {
                if (this.currentImageData) {
                    this.filename.textContent = this.currentImageData.filename;
                    this.folder.textContent = `ðŸ“ ${this.currentImageData.folder}`;

                    // Auto-hide info after 3 seconds if visible
                    if (!this.infoOverlay.classList.contains('hidden')) {
                        setTimeout(() => {
                            this.infoOverlay.classList.add('hidden');
                        }, 3000);
                    }
                }
            }

            async nextImage() {
                this.resetProgress();
                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                    }
                }

                if (this.isPlaying) {
                    this.scheduleNext();
                }
            }

            scheduleNext() {
                this.clearTimers();
                this.timer = setTimeout(() => this.nextImage(), this.interval);
                this.startProgress();
            }

            startProgress() {
                this.progressBar.style.width = '0%';
                let progress = 0;
                const increment = 100 / (this.interval / 100);

                this.progressTimer = setInterval(() => {
                    progress += increment;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(this.progressTimer);
                    }
                    this.progressBar.style.width = progress + '%';
                }, 100);
            }

            resetProgress() {
                this.progressBar.style.width = '0%';
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
            }

            clearTimers() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    const element = document.documentElement;
                    
                    if (element.requestFullscreen) {
                        element.requestFullscreen().then(() => {
                            document.body.classList.add('fullscreen');
                            this.showControlsTemporarily();
                        }).catch((err) => {
                            console.error('Error attempting to enable fullscreen:', err);
                        });
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                        document.body.classList.add('fullscreen');
                        this.showControlsTemporarily();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                        document.body.classList.add('fullscreen');
                        this.showControlsTemporarily();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen().then(() => {
                            document.body.classList.remove('fullscreen');
                        }).catch((err) => {
                            console.error('Error attempting to exit fullscreen:', err);
                        });
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                        document.body.classList.remove('fullscreen');
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                        document.body.classList.remove('fullscreen');
                    }
                }
            }

            toggleInfo() {
                this.infoOverlay.classList.toggle('hidden');
            }

            togglePlayPause() {
                this.isPlaying = !this.isPlaying;
                
                if (this.isPlaying) {
                    // Resume slideshow
                    this.scheduleNext();
                } else {
                    // Pause slideshow
                    this.clearTimers();
                    this.resetProgress();
                }
            }

            logout() {
                if (window.authManager) {
                    window.authManager.logout();
                }
            }

            showControlsTemporarily() {
                const controls = document.getElementById('controls');
                
                // Clear any existing hide timer
                if (this.controlsHideTimer) {
                    clearTimeout(this.controlsHideTimer);
                }
                
                // Show controls
                controls.style.opacity = '1';
                controls.style.transition = 'opacity 0.3s ease';
                
                // Hide controls after 3 seconds of inactivity
                this.controlsHideTimer = setTimeout(() => {
                    controls.style.opacity = '0';
                }, 3000);
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorState.classList.remove('hidden');
                this.loadingState.classList.add('hidden');
            }

            hideError() {
                this.errorState.classList.add('hidden');
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');

                        document.addEventListener('visibilitychange', async () => {
                            if (this.wakeLock !== null && document.visibilityState === 'visible') {
                                try {
                                    this.wakeLock = await navigator.wakeLock.request('screen');
                                } catch (err) {
                                    console.error('Failed to re-activate wake lock:', err);
                                }
                            }
                        });
                    }
                } catch (err) {
                    console.error('Failed to activate wake lock:', err);
                }
            }

            setupCursorAutoHide() {
                const hideCursor = () => {
                    document.body.classList.add('hide-cursor');
                };

                const showCursor = () => {
                    document.body.classList.remove('hide-cursor');
                    clearTimeout(this.cursorHideTimer);
                    this.cursorHideTimer = setTimeout(hideCursor, 3000);
                };

                document.addEventListener('mousemove', showCursor);
                document.addEventListener('mousedown', showCursor);
                document.addEventListener('keydown', showCursor);

                this.cursorHideTimer = setTimeout(hideCursor, 3000);
            }

            initializeFolderSelector() {
                const container = document.getElementById('folderSelector');
                if (container && window.FolderSelector) {
                    this.folderSelector = new FolderSelector(container, {
                        onFolderChanged: (folderPath, folderName) => {
                            this.onFolderChanged(folderPath, folderName);
                        },
                        showFolderCount: true,
                        autoClose: true
                    });

                    this.folderSelector.folders = [];
                    this.folderSelector.renderFolders();
                }
            }

            async onFolderChanged(folderPath, folderName) {
                this.clearTimers();
                this.resetProgress();

                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                        this.scheduleNext();
                    } else {
                        this.showError('Failed to load image from selected folder');
                    }
                } else {
                    this.showError(`No images found in folder: ${folderName || 'All Folders'}`);
                }
            }

            cleanup() {
                this.clearTimers();

                if (this.cursorHideTimer) {
                    clearTimeout(this.cursorHideTimer);
                    this.cursorHideTimer = null;
                }

                if (this.controlsHideTimer) {
                    clearTimeout(this.controlsHideTimer);
                    this.controlsHideTimer = null;
                }

                if (this.wakeLock !== null) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                }
            }

            async startSlideshow() {
                this.hideError();

                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                        this.scheduleNext();
                    } else {
                        this.showError('Failed to load first image');
                    }
                } else {
                    this.showError('No images available');
                }
            }
        }

        // Weather and Clock Widget
        class WeatherWidget {
            constructor() {
                this.timeDisplay = document.getElementById('timeDisplay');
                this.dateDisplay = document.getElementById('dateDisplay');
                this.weatherIcon = document.getElementById('weatherIcon');
                this.tempDisplay = document.getElementById('tempDisplay');
                this.widget = document.getElementById('weatherWidget');
                
                this.lat = null;
                this.lon = null;
                this.weatherData = null;
                this.updateInterval = null;
                this.weatherInterval = null;
                
                this.checkAndInit();
            }

            checkAndInit() {
                // Check if weather widget is enabled (default: true)
                const enabled = localStorage.getItem('weatherWidgetEnabled') !== 'false';
                
                if (enabled) {
                    this.show();
                    this.init();
                } else {
                    this.hide();
                }
                
                // Update date display visibility
                this.updateDateVisibility();
                
                // Listen for changes in localStorage
                window.addEventListener('storage', (e) => {
                    if (e.key === 'weatherWidgetEnabled') {
                        const isEnabled = e.newValue !== 'false';
                        if (isEnabled) {
                            this.show();
                            if (!this.updateInterval) this.init();
                        } else {
                            this.hide();
                        }
                    }
                    // Update temperature display when unit changes
                    if (e.key === 'temperatureUnit' && this.weatherData) {
                        this.updateTemperatureDisplay();
                    }
                    // Update date display when toggled
                    if (e.key === 'dateDisplayEnabled') {
                        this.updateDateVisibility();
                    }
                    // Update time display when format changes
                    if (e.key === 'timeFormat') {
                        this.updateTime();
                    }
                });
            }

            show() {
                if (this.widget) this.widget.style.display = 'flex';
            }

            hide() {
                if (this.widget) this.widget.style.display = 'none';
                this.cleanup();
            }
            
            updateDateVisibility() {
                const enabled = localStorage.getItem('dateDisplayEnabled') !== 'false';
                if (this.dateDisplay) {
                    this.dateDisplay.style.display = enabled ? 'block' : 'none';
                }
            }

            cleanup() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
                if (this.weatherInterval) {
                    clearInterval(this.weatherInterval);
                    this.weatherInterval = null;
                }
            }

            async init() {
                this.updateTime();
                this.updateInterval = setInterval(() => this.updateTime(), 1000);
                
                await this.getLocation();
                await this.updateWeather();
                
                // Update weather every 10 minutes
                this.weatherInterval = setInterval(() => this.updateWeather(), 10 * 60 * 1000);
            }

            updateTime() {
                const now = new Date();
                const format = localStorage.getItem('timeFormat') || '24';
                
                let timeStr;
                if (format === '12') {
                    let hours = now.getHours();
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    hours = hours % 12;
                    hours = hours ? hours : 12; // 0 should be 12
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    timeStr = `${hours}:${minutes} ${ampm}`;
                } else {
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    timeStr = `${hours}:${minutes}`;
                }
                
                this.timeDisplay.textContent = timeStr;
                
                // Update date (e.g., "Mon, Jan 1")
                const options = { weekday: 'short', month: 'short', day: 'numeric' };
                const dateStr = now.toLocaleDateString('en-US', options);
                this.dateDisplay.textContent = dateStr;
            }

            async getLocation() {
                try {
                    // Use ipapi.co for simple IP geolocation (no API key needed)
                    const response = await fetch('https://ipapi.co/json/');
                    const data = await response.json();
                    
                    if (data.latitude && data.longitude) {
                        this.lat = data.latitude;
                        this.lon = data.longitude;
                    }
                } catch (error) {
                    console.error('Failed to get location:', error);
                }
            }

            async updateWeather() {
                if (!this.lat || !this.lon) return;

                try {
                    this.widget.classList.add('loading');
                    
                    // Use Open-Meteo API (free, no API key required)
                    const response = await fetch(
                        `https://api.open-meteo.com/v1/forecast?latitude=${this.lat}&longitude=${this.lon}&current=temperature_2m,weather_code&timezone=auto`
                    );
                    const data = await response.json();
                    
                    if (data.current) {
                        this.weatherData = data.current;
                        const weatherCode = data.current.weather_code;
                        
                        this.updateTemperatureDisplay();
                        this.weatherIcon.textContent = this.getWeatherEmoji(weatherCode);
                    }
                } catch (error) {
                    console.error('Failed to fetch weather:', error);
                } finally {
                    this.widget.classList.remove('loading');
                }
            }

            updateTemperatureDisplay() {
                if (!this.weatherData) return;
                
                const tempC = Math.round(this.weatherData.temperature_2m);
                const unit = localStorage.getItem('temperatureUnit') || 'C';
                
                if (unit === 'F') {
                    const tempF = Math.round((tempC * 9/5) + 32);
                    this.tempDisplay.textContent = `${tempF}Â°F`;
                } else {
                    this.tempDisplay.textContent = `${tempC}Â°C`;
                }
            }

            getWeatherEmoji(code) {
                // WMO Weather interpretation codes - using Unicode symbols
                if (code === 0) return 'â˜€'; // Clear sky
                if (code <= 3) return 'â›…'; // Partly cloudy
                if (code <= 48) return 'ðŸŒ«'; // Fog
                if (code <= 57) return 'ðŸ’§'; // Drizzle
                if (code <= 67) return 'ðŸŒ§'; // Rain
                if (code <= 77) return 'â„'; // Snow
                if (code <= 82) return 'ðŸŒ§'; // Rain showers
                if (code <= 86) return 'ðŸŒ¨'; // Snow showers
                if (code <= 99) return 'â›ˆ'; // Thunderstorm
                return 'â˜'; // Default
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.authManager = new AuthenticationManager();
            window.slideshow = new PhotoFrameSlideshow();
            window.weatherWidget = new WeatherWidget();

            document.addEventListener('authenticationComplete', (e) => {
                console.log('Authentication complete, starting slideshow for:', e.detail.account.name);

                window.slideshow.hideError();
                window.slideshow.initializeFolderSelector();

                // Wait for folder selector to refresh before starting slideshow
                setTimeout(async () => {
                    if (window.slideshow && window.slideshow.folderSelector) {
                        await window.slideshow.folderSelector.refresh();
                    }
                    // Start slideshow after folders are loaded
                    window.slideshow.startSlideshow();
                }, 500);
            });

            window.addEventListener('beforeunload', () => {
                window.slideshow.cleanup();
            });
        });
    </script>
</body>

</html>